
class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        if(desiredTotal <= 0) return true;
        if(maxChoosableInteger * (1+maxChoosableInteger)/2 < desiredTotal) return false;
        
        char[] mem = new char[maxChoosableInteger+1];
        Arrays.fill(mem, '1');
        return dfs(desiredTotal, new HashMap<>(), mem);
    }
    
    private boolean dfs(int desiredTotal, HashMap<String, Boolean> map, char[] mem) {
        if(desiredTotal <= 0) return false;
        String status = new String(mem);
        if(map.containsKey(status)) return map.get(status);
        
        boolean res = false;
        for(int i=1; i<mem.length; i++) {
            if(mem[i] == '0') continue;
            mem[i] = '0';
            if(!dfs(desiredTotal-i, map, mem))
                res = true;
            mem[i] = '1';
            if(res) break;
        }
        map.put(status, res);
        return res;
    }
}


// method 2:

class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        if((1+maxChoosableInteger)*maxChoosableInteger/2 < desiredTotal) return false;
        if(desiredTotal <= 0) return true;
        
        int[] state = new int[maxChoosableInteger+1];
        return canWin(state, desiredTotal, new HashMap<String, Boolean>());
    }
    
    private boolean canWin(int[] state, int total, Map<String, Boolean> hmap) {
        String key = Arrays.toString(state);
        if(hmap.containsKey(key)) {
            return hmap.get(key);
        }
        
        for(int i=1; i<state.length; i++) {
            if(state[i] == 0) {
                state[i] = 1;
                if(total - i <= 0 || !canWin(state, total-i, hmap)) {
                    hmap.put(key, true);
                    state[i] = 0;
                    return true;
                }
                state[i] = 0;
            }
        }
        hmap.put(key, false);
        return false;
    }
}
