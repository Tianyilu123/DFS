
// method : pruning :

class Solution {
    public boolean wordPatternMatch(String pattern, String str) {
        return dfs(pattern, 0, str, 0, new HashMap<Character, String>(), 
                            new HashSet<String>());
    }
    
    private boolean dfs(String pattern, int p_index, String str, int index, 
                            HashMap<Character, String> map, HashSet<String> set) {
        int len = str.length();
        if(index == len && p_index == pattern.length())
            return true;
        if(index >= len || p_index >= pattern.length())
            return false;
        
        char c = pattern.charAt(p_index);
        if(map.containsKey(c)) {
            int curLen = map.get(c).length();
            if(curLen + index > len) return false;
            String target = str.substring(index, index + curLen);
            return target.equals(map.get(c)) ? 
                dfs(pattern, p_index+1, str, curLen + index, map, set) : false;
        } else {
            int maxLen = maxLength(pattern, p_index, str, index, map); // prunning here
            if(maxLen < 1) return false;
            
            for(int ll=1; ll<=maxLen; ll++) { // prunning here
                String curStr = str.substring(index, index+ll);
                if(set.contains(curStr)) continue;
                
                map.put(c, curStr);
                set.add(curStr);
                if(dfs(pattern, p_index+1, str, index+ll, map, set))
                    return true;
                map.remove(c);
                set.remove(curStr);
            }
        }
        
        return false;
    }
    
    // pruning: in pattern, c correspond to string s. However, the maxLength of s can be 
    // calculated using maxLength()
    
    private int maxLength(String pattern, int p_index, String str, int index,
                                    HashMap<Character, String> map) {
        int p_len = pattern.length();
        int s_len = str.length();
        int leftLen = s_len - index, count = 1;
        
        char thisChar = pattern.charAt(p_index);
        for(int i=p_index+1; i<p_len; i++) {
            char c = pattern.charAt(i);
            if(c == thisChar)
                count++;
            else 
                leftLen -= map.containsKey(c) ? map.get(c).length() : 1;
        }
        
        return (int) (leftLen / count);
    }
}



// method 2:

class Solution {
    public boolean wordPatternMatch(String pattern, String str) {
        HashMap<Character, String> map = new HashMap<>();
        HashSet<String> set = new HashSet<>();
        return isMatch(str, 0, pattern, 0, map, set);
    }
    
    private boolean isMatch(String str, int i, String pat, int j, HashMap<Character, String> map,
                                                        HashSet<String> set) {
        if(i == str.length() && j == pat.length()) return true;
        if(i == str.length() || j == pat.length()) return false;
        
        char c = pat.charAt(j);
        if(map.containsKey(c)) {
            String s = map.get(c);
            if(!str.startsWith(s, i)) {
                return false;
            }
            return isMatch(str, i+s.length(), pat, j+1, map, set);
        }
        for(int k = i; k<str.length(); k++) {
            String p = str.substring(i, k+1);
            if(set.contains(p))
                continue;
            map.put(c, p);
            set.add(p);
            if(isMatch(str, k+1, pat, j+1, map, set))
                return true;
            map.remove(c);
            set.remove(p);
        }
        return false;
    }
}
